# -----------------
# Preprocessing
# -----------------
Preprocessing:
  autoreject: !Categorical { choices: [ true, false ] }
  input_length: !Categorical { choices: [ 5, 10, 20 ] }
  sfreq_multiple: !Categorical { choices: [ 2, 3, 4 ] }

# -----------------
# Domain discriminator
# -----------------

# -----------------
# Training
# -----------------
Training:
  learning_rate: !Float { low: 0.00001, high: 0.001, step: null, log: true }
  beta_1: !Float { low: 0.8, high: 1.0, step: null, log: false }
  beta_2: !Float { low: 0.9, high: 1.0, step: null, log: false }
  eps: !Float { low: 0.0000000001, high: 0.000001, step: null, log: true }

Loss:
  loss: { choices: [ MSELoss, L1Loss ] }
  weighter: !Categorical { choices: [ null, SamplePowerWeighter ] }
  weighter_kwargs:
    weight_power: !Float { low: 0, high: 1, step: null, log: false }

# -----------------
# DL architectures
# -----------------
DLArchitectures:
  InceptionNetwork:
    num_classes: 1
    cnn_units: {low: 8, high: 64, step: 1, log: true}
    depth: {low: 3, high: 27, step: 1, log: true}

  ShallowFBCSPNetMTS:
    num_classes: 1
    num_filters: {low: 30, high: 50, step: 1, log: false}
    filter_time_length: {low: 15, high: 35, step: 1, log: false}
    pool_time_stride: {low: 10, high: 20, step: 1, log: false}
    drop_prob: {low: 0.0, high: 0.5, step: null, log: false}

  Deep4NetMTS:
    num_classes: 1
    num_first_filters: { low: 15, high: 35, step: 1, log: false }
    filter_length: { low: 5, high: 15, step: 1, log: false }
    drop_prob: { low: 0.0, high: 0.5, step: null, log: false }

Normalisation: !Categorical { choices: [ true, false ] }

# -----------------
# Varied numbers of channels
# -----------------
_channel_system: # todo: not elegant
Interpolation: &Interpolation
  # todo: not elegant, consider inferring these at runtime
  main_channel_system: { choices: [ LEMON ] }
  methods: { choices: [ MNE, spline ] }


_num_kernels: &num_kernels !Int { low: 100, high: 1000, step: 1, log: true }
_max_receptive_field: &max_receptive_field !Int { low: 100, high: 1000, step: 1, log: true }
RegionBasedPooling:
  num_montage_splits: { low: 1, high: 16, step: 1, log: true }
  share_all_pooling_modules: { choices: [ true, false ] }
  num_pooling_modules_percentage: { low: 0.0, high: 1.0, step: null, log: false }
  num_designs: 1
  pooling_type: multi_cs  # this shouldn't be necessary
  PoolingMethods:
    MultiMSMean: {}
    MultiMSSharedRocket:
      num_kernels: *num_kernels
      max_receptive_field: *max_receptive_field
    MultiMSSharedRocketHeadRegion:
      num_kernels: *num_kernels
      max_receptive_field: *max_receptive_field
      latent_search_features: !Int { low: 8, high: 128, step: 1, log: true }
      share_search_receiver_modules: !Categorical { choices: [ true, false ] }
      bias: !Categorical { choices: [ false ] }
  MontageSplits:
    CentroidPolygons:
      k: !CategoricalDict
        k_1: [ 2, 2, 2, 2, 2, 2, 2 ]
        k_2: [ 3, 3, 3, 3, 3, 3, 3, 3 ]
        k_3: [ 2, 3, 2, 3, 2, 3, 2, 3, 2 ]
        k_4: [ 4, 3, 2, 3, 4, 3, 2, 3, 4 ]
      min_nodes: !Int { low: 1, high: 6, step: 1, log: false }
      channel_system: { choices: [ LEMON ] }  # todo: hard-coded :(

SpatialDimensionMismatch: { choice: [ Interpolation, RegionBasedPooling ] }


